{"id":1260072351,"question_id":2096,"lang":"java","lang_name":"Java","time":"2Â weeks","timestamp":1715905647,"status":10,"status_display":"Accepted","runtime":"75 ms","url":"/submissions/detail/1260072351/","is_pending":"Not Pending","title":"Find the Longest Valid Obstacle Course at Each Position","memory":"65.6 MB","code":"import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    public int[] longestObstacleCourseAtEachPosition(int[] obstacles) {\n        List<Integer> course = new ArrayList<>();\n        List<Integer> result = new ArrayList<>();\n        \n        for (int obstacle : obstacles) {\n            int idx = binarySearch(course, obstacle);\n            if (idx == course.size()) {\n                course.add(obstacle);\n            } else {\n                course.set(idx, obstacle);\n            }\n            result.add(idx + 1);\n        }\n        \n        // Convert List<Integer> to int[]\n        int[] resArray = new int[result.size()];\n        for (int i = 0; i < result.size(); i++) {\n            resArray[i] = result.get(i);\n        }\n        \n        return resArray;\n    }\n    \n    private int binarySearch(List<Integer> course, int target) {\n        int left = 0, right = course.size();\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (course.get(mid) <= target) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n}","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"find-the-longest-valid-obstacle-course-at-each-position","has_notes":false,"flag_type":1}